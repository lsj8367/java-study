# 배열

같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 배열이라고 한다.

만약 과일들을 여러개 생성해야한다고 한다면

## 배열의 생성

```java
public class Fruit {
    String apple = "사과";
    String strawberry = "딸기";
    String orange = "오렌지";
    String banana = "바나나";
}
```

이렇게 여러 과일을 저장하려고 메모리를 중구난방으로 할당한다.

근데 이 배열을 사용하면 배열의 길이만 달라질뿐, 연속된 주소값에 여러 데이터를 갖고 있게 된다.

```java
public class Fruit {
    String[] fruits = {"사과", "딸기", "오렌지", "바나나"};
}
```

## 선언하기

선언방법에는 2가지가 있는데,

- `String[] fruits;`
  - 컨벤션에서 이렇게 많이 사용한다. 
- `String fruits[];`

선언을 해준다음에는 배열을 생성해주어야 한다.

배열을 생성하기 위해서는 `new`를 사용해도 되지만 생성과 동시에 초기화를 해줄 수도 있다.

`String[] fruits = new String[5];`

이렇게 자리만 할당해주는 경우와, 위의 예시처럼 바로 직접 할당하는 방법이 있다.

이 배열요소는 자동으로 해당하는 자료형의 기본값으로 초기화 된다.

배열의 총 길이를 5라고 위에서 할당해 주었는데,

저 길이는 1부터 세서 5까지 되는것이지만, 실제로 `index` 값은 0부터 시작한다.

그래서 자리에 값을 할당해줄때는 `arr[0]` ~ `arr[총길이 - 1]` 까지 가능하다.

## ArrayIndexOutOfBoundException

![스크린샷 2021-11-01 오후 9 38 30](https://user-images.githubusercontent.com/74235102/139672741-a350b92c-e1f8-42b0-9adc-2adbd6a8a0ca.png)

![스크린샷 2021-11-01 오후 9 39 34](https://user-images.githubusercontent.com/74235102/139672805-a17310a5-13f5-44f2-beee-2b67eaa8e548.png)

먼저 자리를 정해주고 나서 2개를 할당하려고 하면 `ArrayIndexOutofBoundException`이 발생하게 된다.

공간을 정해놓았기 때문에 배열은 동적이 아니라서 예외가 발생하게 되는 것이다.

이름도 참 잘지었다고 생각한 것은 배열의 위치가 적절치 못해 복사하려는 내용보다 여유 공간이 적으면 에러를 발생시킨다.

단순히 이 예시 뿐만아니라,

`int[] arr = new int[]{};`

`int[] arr = {};`

이 두가지도 동일한 예외를 발생시킨다.

오늘에서야 알게된 내용이었지만,

주소를 출력한다는건 이미 int형 배열이기 때문에 참조형 변수라서 주소를 출력 해줄줄은 알았지만,

`타입@주소` 형식이라는건 좀 의외였다.

@ 뒤는 16진수의 내부주소이다.

> `char`배열만 유일하게 `System.out.println()`를 했을 때, 구분자 없이 연달아서 출력된다.

## 배열의 복사

아쉽게도 배열은 동적으로 공간을 늘려서 먼저 잡아줬던 크기보다 점점 크게 늘려갈 수가 없다.

그래서 이전 배열보다 더 큰 공간을 할당해주고 싶다면, 기존의 배열 값은 가져가는채로

지금의 길이보다 더 긴 길이의 배열을 만들어주어야 한다.

## 다차원 배열

다차원 배열의 선언 방식은

```java
public class Array {
    String[][] arr = new String[5][5];
}
```

이렇게 선언해주는데 `String[행][렬]` 이라고 보면된다.

그래서 왼쪽은 행을 담당, 오른쪽은 열을 담당한다.

배열 x행 y열의 값을 출력하려면 `println(배열[x][y])` 이 되면 되겠다.

다차원 배열 연습은 [별 찍기](https://www.acmicpc.net/problemset?search=%EB%B3%84+%EC%B0%8D%EA%B8%B0) 가

최고인것 같다고 생각한다.